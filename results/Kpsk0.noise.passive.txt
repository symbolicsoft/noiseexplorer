File "Kpsk0.noise.passive.pv", line 209, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 218, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 219, characters 7-8:
Warning: identifier cs rebound.
File "Kpsk0.noise.passive.pv", line 219, character 36:
Warning: identifier h rebound.
File "Kpsk0.noise.passive.pv", line 249, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 250, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 255, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 256, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 263, character 6:
Warning: identifier e rebound.
File "Kpsk0.noise.passive.pv", line 264, characters 6-7:
Warning: identifier ne rebound.
File "Kpsk0.noise.passive.pv", line 265, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 269, characters 7-8:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 269, characters 26-35:
Warning: identifier ciphertext rebound.
File "Kpsk0.noise.passive.pv", line 270, characters 6-7:
Warning: identifier hs rebound.
File "Kpsk0.noise.passive.pv", line 279, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 280, characters 6-7:
Warning: identifier re rebound.
File "Kpsk0.noise.passive.pv", line 281, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 283, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 284, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 285, characters 7-8:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 287, characters 7-8:
Warning: identifier hs rebound.
File "Kpsk0.noise.passive.pv", line 360, characters 8-9:
Warning: identifier hs rebound.
File "Kpsk0.noise.passive.pv", line 262, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 263, character 6:
Warning: identifier e rebound.
File "Kpsk0.noise.passive.pv", line 264, characters 6-7:
Warning: identifier ne rebound.
File "Kpsk0.noise.passive.pv", line 265, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 266, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 267, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 268, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 269, characters 7-8:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 269, characters 26-35:
Warning: identifier ciphertext rebound.
File "Kpsk0.noise.passive.pv", line 270, characters 6-7:
Warning: identifier hs rebound.
File "Kpsk0.noise.passive.pv", line 218, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 219, characters 7-8:
Warning: identifier cs rebound.
File "Kpsk0.noise.passive.pv", line 219, character 36:
Warning: identifier h rebound.
File "Kpsk0.noise.passive.pv", line 209, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 209, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 209, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 249, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 250, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 392, characters 8-9:
Warning: identifier hs rebound.
File "Kpsk0.noise.passive.pv", line 279, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 280, characters 6-7:
Warning: identifier re rebound.
File "Kpsk0.noise.passive.pv", line 281, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 282, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 283, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 284, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 285, characters 7-8:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 287, characters 7-8:
Warning: identifier hs rebound.
File "Kpsk0.noise.passive.pv", line 218, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 219, characters 7-8:
Warning: identifier cs rebound.
File "Kpsk0.noise.passive.pv", line 219, character 36:
Warning: identifier h rebound.
File "Kpsk0.noise.passive.pv", line 209, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 209, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 209, characters 7-8:
Warning: identifier ck rebound.
File "Kpsk0.noise.passive.pv", line 255, characters 6-7:
Warning: identifier ss rebound.
File "Kpsk0.noise.passive.pv", line 256, characters 6-7:
Warning: identifier ss rebound.
Linear part:
dhexp_real(b_65,dhexp_real(a_64,g)) = dhexp_real(a_64,dhexp_real(b_65,g))
Completing equations...
Completed equations:
dhexp_real(b_65,dhexp_real(a_64,g)) = dhexp_real(a_64,dhexp_real(b_65,g))
Convergent part:
Completing equations...
Completed equations:
Process:
{1}out(pub, key_s(charlie));
{2}!
{3}new sid: sessionid;
(
    {4}let v_390: key = catch-fail(dhexp(key_s(alice),validkey(g))) in
    {5}let s_391: keypair = (if not-caught-fail(v_390) then keypairpack(validkey(v_390),key_s(alice)) else fail-any) in
    {6}out(pub, getpublickey(s_391));
    (
        {7}let e_392: keypair = keypairpack(empty,empty) in
        {8}let v_393: key = catch-fail(dhexp(key_s(bob),validkey(g))) in
        {9}let rs_394: key = getpublickey((if not-caught-fail(v_393) then keypairpack(validkey(v_393),key_s(bob)) else fail-any)) in
        {10}let re_395: key = empty in
        {11}let v_396: bitstring = catch-fail(hash(somename,empty)) in
        {12}let v_397: key = catch-fail(v_396) in
        {13}let v_398: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {14}let v_399: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_396) then (if not-caught-fail(v_397) then (if not-caught-fail(v_398) then symmetricstatepack(v_398,v_397,v_396) else fail-any) else fail-any) else fail-any))) in
        {15}let v_400: symmetricstate = catch-fail((if success?((if not-caught-fail(v_396) then (if not-caught-fail(v_397) then (if not-caught-fail(v_398) then symmetricstatepack(v_398,v_397,v_396) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_399) && success?(is-true(success?(1-proj-3-tuple(v_399))))) then symmetricstatepack(1-proj-3-tuple(v_399),2-proj-3-tuple(v_399),hash(3-proj-3-tuple(v_399),empty)) else fail-any) else fail-any)) in
        {16}let v_401: bitstring = catch-fail(symmetricstateunpack(v_400)) in
        {17}let v_402: symmetricstate = catch-fail((if success?(getpublickey(s_391)) then (if (not-caught-fail(v_401) && success?(is-true(success?(1-proj-3-tuple(v_401))))) then symmetricstatepack(1-proj-3-tuple(v_401),2-proj-3-tuple(v_401),hash(3-proj-3-tuple(v_401),getpublickey(s_391))) else fail-any) else fail-any)) in
        {18}let v_403: bitstring = catch-fail(symmetricstateunpack(v_402)) in
        {19}let v_404: symmetricstate = catch-fail((if (not-caught-fail(v_403) && success?(is-true(success?(1-proj-3-tuple(v_403))))) then symmetricstatepack(1-proj-3-tuple(v_403),2-proj-3-tuple(v_403),hash(3-proj-3-tuple(v_403),rs_394)) else fail-any)) in
        {20}let hs: handshakestate = (if not-caught-fail(v_400) then (if not-caught-fail(v_402) then (if not-caught-fail(v_404) then handshakestatepack(v_404,s_391,e_392,rs_394,re_395,key_psk(alice,bob),true) else fail-any) else fail-any) else fail-any) in
        {21}insert statestore(alice,bob,sid,statepack_a(hs))
    ) | (
        {79}get statestore(=alice,=bob,=sid,statepack_a(hs_405: handshakestate)) in
        {22}let v_406: bitstring = catch-fail(handshakestateunpack(hs_405)) in
        {23}let v_407: bitstring = catch-fail((empty,empty,empty)) in
        {24}let v_408: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_406))) in
        {25}let v_409: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_408),6-proj-7-tuple(v_406))) in
        {26}let v_410: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_408),6-proj-7-tuple(v_406))) in
        {27}let v_411: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_408),6-proj-7-tuple(v_406))) in
        {28}let v_412: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_406)) && success?(2-proj-3-tuple(v_408))) then (if not-caught-fail(v_409) then (if not-caught-fail(v_410) then (if not-caught-fail(v_411) then (v_409,v_410,v_411) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {29}let v_413: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_408),1-proj-3-tuple(v_412),3-proj-3-tuple(v_408)))) in
        {30}let v_414: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_412)) && success?(symmetricstatepack(1-proj-3-tuple(v_408),1-proj-3-tuple(v_412),3-proj-3-tuple(v_408)))) then (if (not-caught-fail(v_413) && success?(is-true(success?(1-proj-3-tuple(v_413))))) then symmetricstatepack(1-proj-3-tuple(v_413),2-proj-3-tuple(v_413),hash(3-proj-3-tuple(v_413),2-proj-3-tuple(v_412))) else fail-any) else fail-any))) in
        {31}let v_415: symmetricstate = catch-fail((if (success?(6-proj-7-tuple(v_406)) && success?(1-proj-7-tuple(v_406))) then (if (not-caught-fail(v_408) && success?(is-true(success?(1-proj-3-tuple(v_408))))) then (if (not-caught-fail(v_412) && success?(is-true(success?(1-proj-3-tuple(v_412))))) then (if (not-caught-fail(v_414) && success?(is-true(success?(1-proj-3-tuple(v_414))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_412)) then cipherstatepack(3-proj-3-tuple(v_412),minnonce) else fail-any),1-proj-3-tuple(v_412),3-proj-3-tuple(v_414)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {32}let v_416: key = catch-fail(dhexp(key_e(alice,bob,sid),validkey(g))) in
        {33}let v_417: keypair = catch-fail((if not-caught-fail(v_416) then keypairpack(validkey(v_416),key_e(alice,bob,sid)) else fail-any)) in
        {34}let v_418: bitstring = catch-fail(getpublickey(v_417)) in
        {35}let v_419: bitstring = catch-fail(symmetricstateunpack(v_415)) in
        {36}let v_420: symmetricstate = catch-fail((if (not-caught-fail(v_419) && success?(is-true(success?(1-proj-3-tuple(v_419))))) then symmetricstatepack(1-proj-3-tuple(v_419),2-proj-3-tuple(v_419),hash(3-proj-3-tuple(v_419),v_418)) else fail-any)) in
        {37}let v_421: bitstring = catch-fail(symmetricstateunpack(v_420)) in
        {38}let v_422: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_421),getpublickey(v_417))) in
        {39}let v_423: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_421),getpublickey(v_417))) in
        {40}let v_424: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_421),getpublickey(v_417))) in
        {41}let v_425: bitstring = catch-fail((if (success?(getpublickey(v_417)) && success?(2-proj-3-tuple(v_421))) then (if not-caught-fail(v_422) then (if not-caught-fail(v_423) then (if not-caught-fail(v_424) then (v_422,v_423,v_424) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {42}let v_426: symmetricstate = catch-fail((if success?(getpublickey(v_417)) then (if (not-caught-fail(v_421) && success?(is-true(success?(1-proj-3-tuple(v_421))))) then (if (not-caught-fail(v_425) && success?(is-true(success?(1-proj-3-tuple(v_425))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_425)) then cipherstatepack(2-proj-3-tuple(v_425),minnonce) else fail-any),1-proj-3-tuple(v_425),3-proj-3-tuple(v_421)) else fail-any) else fail-any) else fail-any)) in
        {43}let v_427: bitstring = catch-fail(keypairunpack(v_417)) in
        {44}let v_428: bitstring = catch-fail(symmetricstateunpack(v_426)) in
        {45}let v_429: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_428),(if success?(4-proj-7-tuple(v_406)) then (if (not-caught-fail(v_427) && success?(is-true(success?(1-proj-2-tuple(v_427))))) then dhexp(2-proj-2-tuple(v_427),4-proj-7-tuple(v_406)) else fail-any) else fail-any))) in
        {46}let v_430: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_428),(if success?(4-proj-7-tuple(v_406)) then (if (not-caught-fail(v_427) && success?(is-true(success?(1-proj-2-tuple(v_427))))) then dhexp(2-proj-2-tuple(v_427),4-proj-7-tuple(v_406)) else fail-any) else fail-any))) in
        {47}let v_431: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_428),(if success?(4-proj-7-tuple(v_406)) then (if (not-caught-fail(v_427) && success?(is-true(success?(1-proj-2-tuple(v_427))))) then dhexp(2-proj-2-tuple(v_427),4-proj-7-tuple(v_406)) else fail-any) else fail-any))) in
        {48}let v_432: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_406)) then (if (not-caught-fail(v_427) && success?(is-true(success?(1-proj-2-tuple(v_427))))) then dhexp(2-proj-2-tuple(v_427),4-proj-7-tuple(v_406)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_428))) then (if not-caught-fail(v_429) then (if not-caught-fail(v_430) then (if not-caught-fail(v_431) then (v_429,v_430,v_431) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {49}let v_433: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_406)) then (if (not-caught-fail(v_427) && success?(is-true(success?(1-proj-2-tuple(v_427))))) then dhexp(2-proj-2-tuple(v_427),4-proj-7-tuple(v_406)) else fail-any) else fail-any)) then (if (not-caught-fail(v_428) && success?(is-true(success?(1-proj-3-tuple(v_428))))) then (if (not-caught-fail(v_432) && success?(is-true(success?(1-proj-3-tuple(v_432))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_432)) then cipherstatepack(2-proj-3-tuple(v_432),minnonce) else fail-any),1-proj-3-tuple(v_432),3-proj-3-tuple(v_428)) else fail-any) else fail-any) else fail-any)) in
        {50}let v_434: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_406))) in
        {51}let v_435: bitstring = catch-fail(symmetricstateunpack(v_433)) in
        {52}let v_436: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_435),(if (success?(4-proj-7-tuple(v_406)) && success?(2-proj-7-tuple(v_406))) then (if (not-caught-fail(v_434) && success?(is-true(success?(1-proj-2-tuple(v_434))))) then dhexp(2-proj-2-tuple(v_434),4-proj-7-tuple(v_406)) else fail-any) else fail-any))) in
        {53}let v_437: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_435),(if (success?(4-proj-7-tuple(v_406)) && success?(2-proj-7-tuple(v_406))) then (if (not-caught-fail(v_434) && success?(is-true(success?(1-proj-2-tuple(v_434))))) then dhexp(2-proj-2-tuple(v_434),4-proj-7-tuple(v_406)) else fail-any) else fail-any))) in
        {54}let v_438: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_435),(if (success?(4-proj-7-tuple(v_406)) && success?(2-proj-7-tuple(v_406))) then (if (not-caught-fail(v_434) && success?(is-true(success?(1-proj-2-tuple(v_434))))) then dhexp(2-proj-2-tuple(v_434),4-proj-7-tuple(v_406)) else fail-any) else fail-any))) in
        {55}let v_439: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_406)) && success?(2-proj-7-tuple(v_406))) then (if (not-caught-fail(v_434) && success?(is-true(success?(1-proj-2-tuple(v_434))))) then dhexp(2-proj-2-tuple(v_434),4-proj-7-tuple(v_406)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_435))) then (if not-caught-fail(v_436) then (if not-caught-fail(v_437) then (if not-caught-fail(v_438) then (v_436,v_437,v_438) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {56}let v_440: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_406)) && success?(2-proj-7-tuple(v_406))) then (if (not-caught-fail(v_434) && success?(is-true(success?(1-proj-2-tuple(v_434))))) then dhexp(2-proj-2-tuple(v_434),4-proj-7-tuple(v_406)) else fail-any) else fail-any)) then (if (not-caught-fail(v_435) && success?(is-true(success?(1-proj-3-tuple(v_435))))) then (if (not-caught-fail(v_439) && success?(is-true(success?(1-proj-3-tuple(v_439))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_439)) then cipherstatepack(2-proj-3-tuple(v_439),minnonce) else fail-any),1-proj-3-tuple(v_439),3-proj-3-tuple(v_435)) else fail-any) else fail-any) else fail-any)) in
        {57}let v_441: bitstring = catch-fail(symmetricstateunpack(v_440)) in
        {58}let v_442: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_441))) in
        {59}let v_443: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_442),2-proj-2-tuple(v_442),3-proj-3-tuple(v_441),msg_a(alice,bob,sid))) in
        {60}let v_444: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_441))) in
        {61}let v_445: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_442))) && success?(1-proj-3-tuple(v_441))) then (if (not-caught-fail(v_444) && success?(is-true(success?(1-proj-2-tuple(v_444))))) then cipherstatepack(1-proj-2-tuple(v_444),increment_nonce(2-proj-2-tuple(v_442))) else fail-any) else fail-any)) in
        {62}let v_446: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_441)) && success?(1-proj-3-tuple(v_441))) then (if (not-caught-fail(v_442) && success?(is-true(success?(1-proj-2-tuple(v_442))))) then (if not-caught-fail(v_443) then (if not-caught-fail(v_445) then (v_445,v_443) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {63}let v_447: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_446),2-proj-3-tuple(v_441),3-proj-3-tuple(v_441)))) in
        {64}let v_448: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_446)) && success?(symmetricstatepack(1-proj-2-tuple(v_446),2-proj-3-tuple(v_441),3-proj-3-tuple(v_441)))) then (if (not-caught-fail(v_447) && success?(is-true(success?(1-proj-3-tuple(v_447))))) then symmetricstatepack(1-proj-3-tuple(v_447),2-proj-3-tuple(v_447),hash(3-proj-3-tuple(v_447),2-proj-2-tuple(v_446))) else fail-any) else fail-any)) in
        {65}let v_449: bitstring = catch-fail((if (not-caught-fail(v_441) && success?(is-true(success?(1-proj-3-tuple(v_441))))) then (if (not-caught-fail(v_446) && success?(is-true(success?(1-proj-2-tuple(v_446))))) then (if not-caught-fail(v_448) then (v_448,2-proj-2-tuple(v_446)) else fail-any) else fail-any) else fail-any)) in
        {66}let v_450: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_449),2-proj-7-tuple(v_406),v_417,4-proj-7-tuple(v_406),5-proj-7-tuple(v_406),6-proj-7-tuple(v_406),7-proj-7-tuple(v_406))) in
        {67}let v_451: bitstring = catch-fail(concat3(v_418,2-proj-3-tuple(v_407),2-proj-2-tuple(v_449))) in
        {68}let v_452: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_449))) in
        {69}let v_453: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_452),zero)) in
        {70}let v_454: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_452),zero)) in
        {71}let v_455: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_452),zero)) in
        {72}let v_456: bitstring = catch-fail((if success?(2-proj-3-tuple(v_452)) then (if not-caught-fail(v_453) then (if not-caught-fail(v_454) then (if not-caught-fail(v_455) then (v_453,v_454,v_455) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {73}let v_457: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_456)) then cipherstatepack(1-proj-3-tuple(v_456),minnonce) else fail-any)) in
        {74}let v_458: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_456)) then cipherstatepack(2-proj-3-tuple(v_456),minnonce) else fail-any)) in
        {75}let v_459: bitstring = catch-fail((if success?(1-proj-2-tuple(v_449)) then (if (not-caught-fail(v_452) && success?(is-true(success?(1-proj-3-tuple(v_452))))) then (if (not-caught-fail(v_456) && success?(is-true(success?(1-proj-3-tuple(v_456))))) then (if not-caught-fail(v_457) then (if not-caught-fail(v_458) then (1-proj-2-tuple(v_449),v_457,v_458) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {76}let (hs_460: handshakestate,message_a: bitstring,cs1: cipherstate,cs2: cipherstate) = (if (not-caught-fail(v_406) && success?(is-true(success?(1-proj-7-tuple(v_406))))) then (if (not-caught-fail(v_407) && success?(is-true(success?(1-proj-3-tuple(v_407))))) then (if not-caught-fail(v_415) then (if not-caught-fail(v_417) then (if not-caught-fail(v_418) then (if not-caught-fail(v_420) then (if not-caught-fail(v_426) then (if not-caught-fail(v_433) then (if not-caught-fail(v_440) then (if (not-caught-fail(v_449) && success?(is-true(success?(1-proj-2-tuple(v_449))))) then (if not-caught-fail(v_450) then (if not-caught-fail(v_451) then (if (not-caught-fail(v_459) && success?(is-true(success?(1-proj-3-tuple(v_459))))) then (v_450,v_451,2-proj-3-tuple(v_459),3-proj-3-tuple(v_459)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {77}event SendMsg(alice,bob,stagepack_a(sid),msg_a(alice,bob,sid));
        {78}out(pub, message_a)
    ) | (
        {80}event LeakPsk(phase0,alice,bob);
        {81}out(pub, key_psk(alice,bob))
    ) | (
        {82}phase 1;
        {83}event LeakPsk(phase1,alice,bob);
        {84}out(pub, key_psk(alice,bob))
    ) | (
        {85}event LeakS(phase0,alice);
        {86}out(pub, key_s(alice))
    ) | (
        {87}phase 1;
        {88}event LeakS(phase1,alice);
        {89}out(pub, key_s(alice))
    )
) | (
    {90}let v_461: key = catch-fail(dhexp(key_s(alice),validkey(g))) in
    {91}let s_462: keypair = (if not-caught-fail(v_461) then keypairpack(validkey(v_461),key_s(alice)) else fail-any) in
    {92}out(pub, getpublickey(s_462));
    (
        {93}let e_463: keypair = keypairpack(empty,empty) in
        {94}let v_464: key = catch-fail(dhexp(key_s(charlie),validkey(g))) in
        {95}let rs_465: key = getpublickey((if not-caught-fail(v_464) then keypairpack(validkey(v_464),key_s(charlie)) else fail-any)) in
        {96}let re_466: key = empty in
        {97}let v_467: bitstring = catch-fail(hash(somename,empty)) in
        {98}let v_468: key = catch-fail(v_467) in
        {99}let v_469: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {100}let v_470: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_467) then (if not-caught-fail(v_468) then (if not-caught-fail(v_469) then symmetricstatepack(v_469,v_468,v_467) else fail-any) else fail-any) else fail-any))) in
        {101}let v_471: symmetricstate = catch-fail((if success?((if not-caught-fail(v_467) then (if not-caught-fail(v_468) then (if not-caught-fail(v_469) then symmetricstatepack(v_469,v_468,v_467) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_470) && success?(is-true(success?(1-proj-3-tuple(v_470))))) then symmetricstatepack(1-proj-3-tuple(v_470),2-proj-3-tuple(v_470),hash(3-proj-3-tuple(v_470),empty)) else fail-any) else fail-any)) in
        {102}let v_472: bitstring = catch-fail(symmetricstateunpack(v_471)) in
        {103}let v_473: symmetricstate = catch-fail((if success?(getpublickey(s_462)) then (if (not-caught-fail(v_472) && success?(is-true(success?(1-proj-3-tuple(v_472))))) then symmetricstatepack(1-proj-3-tuple(v_472),2-proj-3-tuple(v_472),hash(3-proj-3-tuple(v_472),getpublickey(s_462))) else fail-any) else fail-any)) in
        {104}let v_474: bitstring = catch-fail(symmetricstateunpack(v_473)) in
        {105}let v_475: symmetricstate = catch-fail((if (not-caught-fail(v_474) && success?(is-true(success?(1-proj-3-tuple(v_474))))) then symmetricstatepack(1-proj-3-tuple(v_474),2-proj-3-tuple(v_474),hash(3-proj-3-tuple(v_474),rs_465)) else fail-any)) in
        {106}let hs_476: handshakestate = (if not-caught-fail(v_471) then (if not-caught-fail(v_473) then (if not-caught-fail(v_475) then handshakestatepack(v_475,s_462,e_463,rs_465,re_466,key_psk(alice,charlie),true) else fail-any) else fail-any) else fail-any) in
        {107}insert statestore(alice,charlie,sid,statepack_a(hs_476))
    ) | (
        {165}get statestore(=alice,=charlie,=sid,statepack_a(hs_477: handshakestate)) in
        {108}let v_478: bitstring = catch-fail(handshakestateunpack(hs_477)) in
        {109}let v_479: bitstring = catch-fail((empty,empty,empty)) in
        {110}let v_480: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_478))) in
        {111}let v_481: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_480),6-proj-7-tuple(v_478))) in
        {112}let v_482: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_480),6-proj-7-tuple(v_478))) in
        {113}let v_483: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_480),6-proj-7-tuple(v_478))) in
        {114}let v_484: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_478)) && success?(2-proj-3-tuple(v_480))) then (if not-caught-fail(v_481) then (if not-caught-fail(v_482) then (if not-caught-fail(v_483) then (v_481,v_482,v_483) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {115}let v_485: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_480),1-proj-3-tuple(v_484),3-proj-3-tuple(v_480)))) in
        {116}let v_486: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_484)) && success?(symmetricstatepack(1-proj-3-tuple(v_480),1-proj-3-tuple(v_484),3-proj-3-tuple(v_480)))) then (if (not-caught-fail(v_485) && success?(is-true(success?(1-proj-3-tuple(v_485))))) then symmetricstatepack(1-proj-3-tuple(v_485),2-proj-3-tuple(v_485),hash(3-proj-3-tuple(v_485),2-proj-3-tuple(v_484))) else fail-any) else fail-any))) in
        {117}let v_487: symmetricstate = catch-fail((if (success?(6-proj-7-tuple(v_478)) && success?(1-proj-7-tuple(v_478))) then (if (not-caught-fail(v_480) && success?(is-true(success?(1-proj-3-tuple(v_480))))) then (if (not-caught-fail(v_484) && success?(is-true(success?(1-proj-3-tuple(v_484))))) then (if (not-caught-fail(v_486) && success?(is-true(success?(1-proj-3-tuple(v_486))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_484)) then cipherstatepack(3-proj-3-tuple(v_484),minnonce) else fail-any),1-proj-3-tuple(v_484),3-proj-3-tuple(v_486)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {118}let v_488: key = catch-fail(dhexp(key_e(alice,charlie,sid),validkey(g))) in
        {119}let v_489: keypair = catch-fail((if not-caught-fail(v_488) then keypairpack(validkey(v_488),key_e(alice,charlie,sid)) else fail-any)) in
        {120}let v_490: bitstring = catch-fail(getpublickey(v_489)) in
        {121}let v_491: bitstring = catch-fail(symmetricstateunpack(v_487)) in
        {122}let v_492: symmetricstate = catch-fail((if (not-caught-fail(v_491) && success?(is-true(success?(1-proj-3-tuple(v_491))))) then symmetricstatepack(1-proj-3-tuple(v_491),2-proj-3-tuple(v_491),hash(3-proj-3-tuple(v_491),v_490)) else fail-any)) in
        {123}let v_493: bitstring = catch-fail(symmetricstateunpack(v_492)) in
        {124}let v_494: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_493),getpublickey(v_489))) in
        {125}let v_495: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_493),getpublickey(v_489))) in
        {126}let v_496: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_493),getpublickey(v_489))) in
        {127}let v_497: bitstring = catch-fail((if (success?(getpublickey(v_489)) && success?(2-proj-3-tuple(v_493))) then (if not-caught-fail(v_494) then (if not-caught-fail(v_495) then (if not-caught-fail(v_496) then (v_494,v_495,v_496) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {128}let v_498: symmetricstate = catch-fail((if success?(getpublickey(v_489)) then (if (not-caught-fail(v_493) && success?(is-true(success?(1-proj-3-tuple(v_493))))) then (if (not-caught-fail(v_497) && success?(is-true(success?(1-proj-3-tuple(v_497))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_497)) then cipherstatepack(2-proj-3-tuple(v_497),minnonce) else fail-any),1-proj-3-tuple(v_497),3-proj-3-tuple(v_493)) else fail-any) else fail-any) else fail-any)) in
        {129}let v_499: bitstring = catch-fail(keypairunpack(v_489)) in
        {130}let v_500: bitstring = catch-fail(symmetricstateunpack(v_498)) in
        {131}let v_501: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_500),(if success?(4-proj-7-tuple(v_478)) then (if (not-caught-fail(v_499) && success?(is-true(success?(1-proj-2-tuple(v_499))))) then dhexp(2-proj-2-tuple(v_499),4-proj-7-tuple(v_478)) else fail-any) else fail-any))) in
        {132}let v_502: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_500),(if success?(4-proj-7-tuple(v_478)) then (if (not-caught-fail(v_499) && success?(is-true(success?(1-proj-2-tuple(v_499))))) then dhexp(2-proj-2-tuple(v_499),4-proj-7-tuple(v_478)) else fail-any) else fail-any))) in
        {133}let v_503: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_500),(if success?(4-proj-7-tuple(v_478)) then (if (not-caught-fail(v_499) && success?(is-true(success?(1-proj-2-tuple(v_499))))) then dhexp(2-proj-2-tuple(v_499),4-proj-7-tuple(v_478)) else fail-any) else fail-any))) in
        {134}let v_504: bitstring = catch-fail((if (success?((if success?(4-proj-7-tuple(v_478)) then (if (not-caught-fail(v_499) && success?(is-true(success?(1-proj-2-tuple(v_499))))) then dhexp(2-proj-2-tuple(v_499),4-proj-7-tuple(v_478)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_500))) then (if not-caught-fail(v_501) then (if not-caught-fail(v_502) then (if not-caught-fail(v_503) then (v_501,v_502,v_503) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {135}let v_505: symmetricstate = catch-fail((if success?((if success?(4-proj-7-tuple(v_478)) then (if (not-caught-fail(v_499) && success?(is-true(success?(1-proj-2-tuple(v_499))))) then dhexp(2-proj-2-tuple(v_499),4-proj-7-tuple(v_478)) else fail-any) else fail-any)) then (if (not-caught-fail(v_500) && success?(is-true(success?(1-proj-3-tuple(v_500))))) then (if (not-caught-fail(v_504) && success?(is-true(success?(1-proj-3-tuple(v_504))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_504)) then cipherstatepack(2-proj-3-tuple(v_504),minnonce) else fail-any),1-proj-3-tuple(v_504),3-proj-3-tuple(v_500)) else fail-any) else fail-any) else fail-any)) in
        {136}let v_506: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_478))) in
        {137}let v_507: bitstring = catch-fail(symmetricstateunpack(v_505)) in
        {138}let v_508: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_507),(if (success?(4-proj-7-tuple(v_478)) && success?(2-proj-7-tuple(v_478))) then (if (not-caught-fail(v_506) && success?(is-true(success?(1-proj-2-tuple(v_506))))) then dhexp(2-proj-2-tuple(v_506),4-proj-7-tuple(v_478)) else fail-any) else fail-any))) in
        {139}let v_509: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_507),(if (success?(4-proj-7-tuple(v_478)) && success?(2-proj-7-tuple(v_478))) then (if (not-caught-fail(v_506) && success?(is-true(success?(1-proj-2-tuple(v_506))))) then dhexp(2-proj-2-tuple(v_506),4-proj-7-tuple(v_478)) else fail-any) else fail-any))) in
        {140}let v_510: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_507),(if (success?(4-proj-7-tuple(v_478)) && success?(2-proj-7-tuple(v_478))) then (if (not-caught-fail(v_506) && success?(is-true(success?(1-proj-2-tuple(v_506))))) then dhexp(2-proj-2-tuple(v_506),4-proj-7-tuple(v_478)) else fail-any) else fail-any))) in
        {141}let v_511: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_478)) && success?(2-proj-7-tuple(v_478))) then (if (not-caught-fail(v_506) && success?(is-true(success?(1-proj-2-tuple(v_506))))) then dhexp(2-proj-2-tuple(v_506),4-proj-7-tuple(v_478)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_507))) then (if not-caught-fail(v_508) then (if not-caught-fail(v_509) then (if not-caught-fail(v_510) then (v_508,v_509,v_510) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {142}let v_512: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_478)) && success?(2-proj-7-tuple(v_478))) then (if (not-caught-fail(v_506) && success?(is-true(success?(1-proj-2-tuple(v_506))))) then dhexp(2-proj-2-tuple(v_506),4-proj-7-tuple(v_478)) else fail-any) else fail-any)) then (if (not-caught-fail(v_507) && success?(is-true(success?(1-proj-3-tuple(v_507))))) then (if (not-caught-fail(v_511) && success?(is-true(success?(1-proj-3-tuple(v_511))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_511)) then cipherstatepack(2-proj-3-tuple(v_511),minnonce) else fail-any),1-proj-3-tuple(v_511),3-proj-3-tuple(v_507)) else fail-any) else fail-any) else fail-any)) in
        {143}let v_513: bitstring = catch-fail(symmetricstateunpack(v_512)) in
        {144}let v_514: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_513))) in
        {145}let v_515: bitstring = catch-fail(encrypt(1-proj-2-tuple(v_514),2-proj-2-tuple(v_514),3-proj-3-tuple(v_513),msg_a(alice,charlie,sid))) in
        {146}let v_516: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_513))) in
        {147}let v_517: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_514))) && success?(1-proj-3-tuple(v_513))) then (if (not-caught-fail(v_516) && success?(is-true(success?(1-proj-2-tuple(v_516))))) then cipherstatepack(1-proj-2-tuple(v_516),increment_nonce(2-proj-2-tuple(v_514))) else fail-any) else fail-any)) in
        {148}let v_518: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_513)) && success?(1-proj-3-tuple(v_513))) then (if (not-caught-fail(v_514) && success?(is-true(success?(1-proj-2-tuple(v_514))))) then (if not-caught-fail(v_515) then (if not-caught-fail(v_517) then (v_517,v_515) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {149}let v_519: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-2-tuple(v_518),2-proj-3-tuple(v_513),3-proj-3-tuple(v_513)))) in
        {150}let v_520: symmetricstate = catch-fail((if (success?(2-proj-2-tuple(v_518)) && success?(symmetricstatepack(1-proj-2-tuple(v_518),2-proj-3-tuple(v_513),3-proj-3-tuple(v_513)))) then (if (not-caught-fail(v_519) && success?(is-true(success?(1-proj-3-tuple(v_519))))) then symmetricstatepack(1-proj-3-tuple(v_519),2-proj-3-tuple(v_519),hash(3-proj-3-tuple(v_519),2-proj-2-tuple(v_518))) else fail-any) else fail-any)) in
        {151}let v_521: bitstring = catch-fail((if (not-caught-fail(v_513) && success?(is-true(success?(1-proj-3-tuple(v_513))))) then (if (not-caught-fail(v_518) && success?(is-true(success?(1-proj-2-tuple(v_518))))) then (if not-caught-fail(v_520) then (v_520,2-proj-2-tuple(v_518)) else fail-any) else fail-any) else fail-any)) in
        {152}let v_522: handshakestate = catch-fail(handshakestatepack(1-proj-2-tuple(v_521),2-proj-7-tuple(v_478),v_489,4-proj-7-tuple(v_478),5-proj-7-tuple(v_478),6-proj-7-tuple(v_478),7-proj-7-tuple(v_478))) in
        {153}let v_523: bitstring = catch-fail(concat3(v_490,2-proj-3-tuple(v_479),2-proj-2-tuple(v_521))) in
        {154}let v_524: bitstring = catch-fail(symmetricstateunpack(1-proj-2-tuple(v_521))) in
        {155}let v_525: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_524),zero)) in
        {156}let v_526: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_524),zero)) in
        {157}let v_527: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_524),zero)) in
        {158}let v_528: bitstring = catch-fail((if success?(2-proj-3-tuple(v_524)) then (if not-caught-fail(v_525) then (if not-caught-fail(v_526) then (if not-caught-fail(v_527) then (v_525,v_526,v_527) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {159}let v_529: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_528)) then cipherstatepack(1-proj-3-tuple(v_528),minnonce) else fail-any)) in
        {160}let v_530: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_528)) then cipherstatepack(2-proj-3-tuple(v_528),minnonce) else fail-any)) in
        {161}let v_531: bitstring = catch-fail((if success?(1-proj-2-tuple(v_521)) then (if (not-caught-fail(v_524) && success?(is-true(success?(1-proj-3-tuple(v_524))))) then (if (not-caught-fail(v_528) && success?(is-true(success?(1-proj-3-tuple(v_528))))) then (if not-caught-fail(v_529) then (if not-caught-fail(v_530) then (1-proj-2-tuple(v_521),v_529,v_530) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {162}let (hs_532: handshakestate,message_a_533: bitstring,cs1_534: cipherstate,cs2_535: cipherstate) = (if (not-caught-fail(v_478) && success?(is-true(success?(1-proj-7-tuple(v_478))))) then (if (not-caught-fail(v_479) && success?(is-true(success?(1-proj-3-tuple(v_479))))) then (if not-caught-fail(v_487) then (if not-caught-fail(v_489) then (if not-caught-fail(v_490) then (if not-caught-fail(v_492) then (if not-caught-fail(v_498) then (if not-caught-fail(v_505) then (if not-caught-fail(v_512) then (if (not-caught-fail(v_521) && success?(is-true(success?(1-proj-2-tuple(v_521))))) then (if not-caught-fail(v_522) then (if not-caught-fail(v_523) then (if (not-caught-fail(v_531) && success?(is-true(success?(1-proj-3-tuple(v_531))))) then (v_522,v_523,2-proj-3-tuple(v_531),3-proj-3-tuple(v_531)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {163}event SendMsg(alice,charlie,stagepack_a(sid),msg_a(alice,charlie,sid));
        {164}out(pub, message_a_533)
    ) | (
        {166}event LeakPsk(phase0,alice,charlie);
        {167}out(pub, key_psk(alice,charlie))
    ) | (
        {168}phase 1;
        {169}event LeakPsk(phase1,alice,charlie);
        {170}out(pub, key_psk(alice,charlie))
    ) | (
        {171}event LeakS(phase0,alice);
        {172}out(pub, key_s(alice))
    ) | (
        {173}phase 1;
        {174}event LeakS(phase1,alice);
        {175}out(pub, key_s(alice))
    )
) | (
    {176}let v_536: key = catch-fail(dhexp(key_s(bob),validkey(g))) in
    {177}let s_537: keypair = (if not-caught-fail(v_536) then keypairpack(validkey(v_536),key_s(bob)) else fail-any) in
    {178}out(pub, getpublickey(s_537));
    (
        {179}let e_538: keypair = keypairpack(empty,empty) in
        {180}let v_539: key = catch-fail(dhexp(key_s(alice),validkey(g))) in
        {181}let rs_540: key = getpublickey((if not-caught-fail(v_539) then keypairpack(validkey(v_539),key_s(alice)) else fail-any)) in
        {182}let re_541: key = empty in
        {183}let v_542: bitstring = catch-fail(hash(somename,empty)) in
        {184}let v_543: key = catch-fail(v_542) in
        {185}let v_544: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {186}let v_545: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_542) then (if not-caught-fail(v_543) then (if not-caught-fail(v_544) then symmetricstatepack(v_544,v_543,v_542) else fail-any) else fail-any) else fail-any))) in
        {187}let v_546: symmetricstate = catch-fail((if success?((if not-caught-fail(v_542) then (if not-caught-fail(v_543) then (if not-caught-fail(v_544) then symmetricstatepack(v_544,v_543,v_542) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_545) && success?(is-true(success?(1-proj-3-tuple(v_545))))) then symmetricstatepack(1-proj-3-tuple(v_545),2-proj-3-tuple(v_545),hash(3-proj-3-tuple(v_545),empty)) else fail-any) else fail-any)) in
        {188}let v_547: bitstring = catch-fail(symmetricstateunpack(v_546)) in
        {189}let v_548: symmetricstate = catch-fail((if (not-caught-fail(v_547) && success?(is-true(success?(1-proj-3-tuple(v_547))))) then symmetricstatepack(1-proj-3-tuple(v_547),2-proj-3-tuple(v_547),hash(3-proj-3-tuple(v_547),rs_540)) else fail-any)) in
        {190}let v_549: bitstring = catch-fail(symmetricstateunpack(v_548)) in
        {191}let v_550: symmetricstate = catch-fail((if success?(getpublickey(s_537)) then (if (not-caught-fail(v_549) && success?(is-true(success?(1-proj-3-tuple(v_549))))) then symmetricstatepack(1-proj-3-tuple(v_549),2-proj-3-tuple(v_549),hash(3-proj-3-tuple(v_549),getpublickey(s_537))) else fail-any) else fail-any)) in
        {192}let hs_551: handshakestate = (if not-caught-fail(v_546) then (if not-caught-fail(v_548) then (if not-caught-fail(v_550) then handshakestatepack(v_550,s_537,e_538,rs_540,re_541,key_psk(alice,bob),false) else fail-any) else fail-any) else fail-any) in
        {193}insert statestore(bob,alice,sid,statepack_a(hs_551))
    ) | (
        {251}get statestore(=bob,=alice,=sid,statepack_a(hs_552: handshakestate)) in
        {194}in(pub, message_a_553: bitstring);
        {195}let v_554: bitstring = catch-fail(handshakestateunpack(hs_552)) in
        {196}let v_555: bitstring = catch-fail(deconcat3(message_a_553)) in
        {197}let v_556: bool = catch-fail(true) in
        {198}let v_557: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_554))) in
        {199}let v_558: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_557),6-proj-7-tuple(v_554))) in
        {200}let v_559: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_557),6-proj-7-tuple(v_554))) in
        {201}let v_560: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_557),6-proj-7-tuple(v_554))) in
        {202}let v_561: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_554)) && success?(2-proj-3-tuple(v_557))) then (if not-caught-fail(v_558) then (if not-caught-fail(v_559) then (if not-caught-fail(v_560) then (v_558,v_559,v_560) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {203}let v_562: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_557),1-proj-3-tuple(v_561),3-proj-3-tuple(v_557)))) in
        {204}let v_563: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_561)) && success?(symmetricstatepack(1-proj-3-tuple(v_557),1-proj-3-tuple(v_561),3-proj-3-tuple(v_557)))) then (if (not-caught-fail(v_562) && success?(is-true(success?(1-proj-3-tuple(v_562))))) then symmetricstatepack(1-proj-3-tuple(v_562),2-proj-3-tuple(v_562),hash(3-proj-3-tuple(v_562),2-proj-3-tuple(v_561))) else fail-any) else fail-any))) in
        {205}let v_564: symmetricstate = catch-fail((if (success?(6-proj-7-tuple(v_554)) && success?(1-proj-7-tuple(v_554))) then (if (not-caught-fail(v_557) && success?(is-true(success?(1-proj-3-tuple(v_557))))) then (if (not-caught-fail(v_561) && success?(is-true(success?(1-proj-3-tuple(v_561))))) then (if (not-caught-fail(v_563) && success?(is-true(success?(1-proj-3-tuple(v_563))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_561)) then cipherstatepack(3-proj-3-tuple(v_561),minnonce) else fail-any),1-proj-3-tuple(v_561),3-proj-3-tuple(v_563)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {206}let v_565: key = catch-fail(1-proj-3-tuple(v_555)) in
        {207}let v_566: bitstring = catch-fail(symmetricstateunpack(v_564)) in
        {208}let v_567: symmetricstate = catch-fail((if (not-caught-fail(v_566) && success?(is-true(success?(1-proj-3-tuple(v_566))))) then symmetricstatepack(1-proj-3-tuple(v_566),2-proj-3-tuple(v_566),hash(3-proj-3-tuple(v_566),v_565)) else fail-any)) in
        {209}let v_568: bitstring = catch-fail(symmetricstateunpack(v_567)) in
        {210}let v_569: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_568),v_565)) in
        {211}let v_570: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_568),v_565)) in
        {212}let v_571: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_568),v_565)) in
        {213}let v_572: bitstring = catch-fail((if success?(2-proj-3-tuple(v_568)) then (if not-caught-fail(v_569) then (if not-caught-fail(v_570) then (if not-caught-fail(v_571) then (v_569,v_570,v_571) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {214}let v_573: symmetricstate = catch-fail((if (not-caught-fail(v_568) && success?(is-true(success?(1-proj-3-tuple(v_568))))) then (if (not-caught-fail(v_572) && success?(is-true(success?(1-proj-3-tuple(v_572))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_572)) then cipherstatepack(2-proj-3-tuple(v_572),minnonce) else fail-any),1-proj-3-tuple(v_572),3-proj-3-tuple(v_568)) else fail-any) else fail-any)) in
        {215}let v_574: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_554))) in
        {216}let v_575: bitstring = catch-fail(symmetricstateunpack(v_573)) in
        {217}let v_576: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_575),(if success?(2-proj-7-tuple(v_554)) then (if (not-caught-fail(v_574) && success?(is-true(success?(1-proj-2-tuple(v_574))))) then dhexp(2-proj-2-tuple(v_574),v_565) else fail-any) else fail-any))) in
        {218}let v_577: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_575),(if success?(2-proj-7-tuple(v_554)) then (if (not-caught-fail(v_574) && success?(is-true(success?(1-proj-2-tuple(v_574))))) then dhexp(2-proj-2-tuple(v_574),v_565) else fail-any) else fail-any))) in
        {219}let v_578: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_575),(if success?(2-proj-7-tuple(v_554)) then (if (not-caught-fail(v_574) && success?(is-true(success?(1-proj-2-tuple(v_574))))) then dhexp(2-proj-2-tuple(v_574),v_565) else fail-any) else fail-any))) in
        {220}let v_579: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_554)) then (if (not-caught-fail(v_574) && success?(is-true(success?(1-proj-2-tuple(v_574))))) then dhexp(2-proj-2-tuple(v_574),v_565) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_575))) then (if not-caught-fail(v_576) then (if not-caught-fail(v_577) then (if not-caught-fail(v_578) then (v_576,v_577,v_578) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {221}let v_580: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_554)) then (if (not-caught-fail(v_574) && success?(is-true(success?(1-proj-2-tuple(v_574))))) then dhexp(2-proj-2-tuple(v_574),v_565) else fail-any) else fail-any)) then (if (not-caught-fail(v_575) && success?(is-true(success?(1-proj-3-tuple(v_575))))) then (if (not-caught-fail(v_579) && success?(is-true(success?(1-proj-3-tuple(v_579))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_579)) then cipherstatepack(2-proj-3-tuple(v_579),minnonce) else fail-any),1-proj-3-tuple(v_579),3-proj-3-tuple(v_575)) else fail-any) else fail-any) else fail-any)) in
        {222}let v_581: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_554))) in
        {223}let v_582: bitstring = catch-fail(symmetricstateunpack(v_580)) in
        {224}let v_583: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_582),(if (success?(4-proj-7-tuple(v_554)) && success?(2-proj-7-tuple(v_554))) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-2-tuple(v_581))))) then dhexp(2-proj-2-tuple(v_581),4-proj-7-tuple(v_554)) else fail-any) else fail-any))) in
        {225}let v_584: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_582),(if (success?(4-proj-7-tuple(v_554)) && success?(2-proj-7-tuple(v_554))) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-2-tuple(v_581))))) then dhexp(2-proj-2-tuple(v_581),4-proj-7-tuple(v_554)) else fail-any) else fail-any))) in
        {226}let v_585: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_582),(if (success?(4-proj-7-tuple(v_554)) && success?(2-proj-7-tuple(v_554))) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-2-tuple(v_581))))) then dhexp(2-proj-2-tuple(v_581),4-proj-7-tuple(v_554)) else fail-any) else fail-any))) in
        {227}let v_586: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_554)) && success?(2-proj-7-tuple(v_554))) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-2-tuple(v_581))))) then dhexp(2-proj-2-tuple(v_581),4-proj-7-tuple(v_554)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_582))) then (if not-caught-fail(v_583) then (if not-caught-fail(v_584) then (if not-caught-fail(v_585) then (v_583,v_584,v_585) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {228}let v_587: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_554)) && success?(2-proj-7-tuple(v_554))) then (if (not-caught-fail(v_581) && success?(is-true(success?(1-proj-2-tuple(v_581))))) then dhexp(2-proj-2-tuple(v_581),4-proj-7-tuple(v_554)) else fail-any) else fail-any)) then (if (not-caught-fail(v_582) && success?(is-true(success?(1-proj-3-tuple(v_582))))) then (if (not-caught-fail(v_586) && success?(is-true(success?(1-proj-3-tuple(v_586))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_586)) then cipherstatepack(2-proj-3-tuple(v_586),minnonce) else fail-any),1-proj-3-tuple(v_586),3-proj-3-tuple(v_582)) else fail-any) else fail-any) else fail-any)) in
        {229}let v_588: bitstring = catch-fail(symmetricstateunpack(v_587)) in
        {230}let v_589: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_588))) in
        {231}let v_590: aead = catch-fail(decrypt(1-proj-2-tuple(v_589),2-proj-2-tuple(v_589),3-proj-3-tuple(v_588),3-proj-3-tuple(v_555))) in
        {232}let v_591: bitstring = catch-fail(aeadunpack(v_590)) in
        {233}let v_592: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_588))) in
        {234}let v_593: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_589))) && success?(1-proj-3-tuple(v_588))) then (if (not-caught-fail(v_592) && success?(is-true(success?(1-proj-2-tuple(v_592))))) then cipherstatepack(1-proj-2-tuple(v_592),increment_nonce(2-proj-2-tuple(v_589))) else fail-any) else fail-any)) in
        {235}let v_594: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_555)) && (success?(3-proj-3-tuple(v_588)) && success?(1-proj-3-tuple(v_588)))) then (if (not-caught-fail(v_589) && success?(is-true(success?(1-proj-2-tuple(v_589))))) then (if not-caught-fail(v_590) then (if (not-caught-fail(v_591) && success?(is-true(success?(1-proj-3-tuple(v_591))))) then (if not-caught-fail(v_593) then (v_593,3-proj-3-tuple(v_591),1-proj-3-tuple(v_591)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {236}let v_595: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_594),2-proj-3-tuple(v_588),3-proj-3-tuple(v_588)))) in
        {237}let v_596: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_555)) && success?(symmetricstatepack(1-proj-3-tuple(v_594),2-proj-3-tuple(v_588),3-proj-3-tuple(v_588)))) then (if (not-caught-fail(v_595) && success?(is-true(success?(1-proj-3-tuple(v_595))))) then symmetricstatepack(1-proj-3-tuple(v_595),2-proj-3-tuple(v_595),hash(3-proj-3-tuple(v_595),3-proj-3-tuple(v_555))) else fail-any) else fail-any)) in
        {238}let v_597: bitstring = catch-fail((if success?(3-proj-3-tuple(v_555)) then (if (not-caught-fail(v_588) && success?(is-true(success?(1-proj-3-tuple(v_588))))) then (if (not-caught-fail(v_594) && success?(is-true(success?(1-proj-3-tuple(v_594))))) then (if not-caught-fail(v_596) then (v_596,2-proj-3-tuple(v_594),3-proj-3-tuple(v_594)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {239}let v_598: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_597),2-proj-7-tuple(v_554),3-proj-7-tuple(v_554),4-proj-7-tuple(v_554),v_565,6-proj-7-tuple(v_554),7-proj-7-tuple(v_554))) in
        {240}let v_599: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_597))) in
        {241}let v_600: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_599),zero)) in
        {242}let v_601: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_599),zero)) in
        {243}let v_602: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_599),zero)) in
        {244}let v_603: bitstring = catch-fail((if success?(2-proj-3-tuple(v_599)) then (if not-caught-fail(v_600) then (if not-caught-fail(v_601) then (if not-caught-fail(v_602) then (v_600,v_601,v_602) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {245}let v_604: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_603)) then cipherstatepack(1-proj-3-tuple(v_603),minnonce) else fail-any)) in
        {246}let v_605: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_603)) then cipherstatepack(2-proj-3-tuple(v_603),minnonce) else fail-any)) in
        {247}let v_606: bitstring = catch-fail((if success?(1-proj-3-tuple(v_597)) then (if (not-caught-fail(v_599) && success?(is-true(success?(1-proj-3-tuple(v_599))))) then (if (not-caught-fail(v_603) && success?(is-true(success?(1-proj-3-tuple(v_603))))) then (if not-caught-fail(v_604) then (if not-caught-fail(v_605) then (1-proj-3-tuple(v_597),v_604,v_605) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {248}let (hs_607: handshakestate,plaintext_a: bitstring,valid: bool,cs1_608: cipherstate,cs2_609: cipherstate) = (if (not-caught-fail(v_554) && success?(is-true(success?(1-proj-7-tuple(v_554))))) then (if (not-caught-fail(v_555) && success?(is-true(success?(1-proj-3-tuple(v_555))))) then (if not-caught-fail(v_556) then (if not-caught-fail(v_564) then (if not-caught-fail(v_565) then (if not-caught-fail(v_567) then (if not-caught-fail(v_573) then (if not-caught-fail(v_580) then (if not-caught-fail(v_587) then (if (not-caught-fail(v_597) && success?(is-true(success?(1-proj-3-tuple(v_597))))) then (if (v_556 && 3-proj-3-tuple(v_597)) then (if not-caught-fail(v_598) then (if (not-caught-fail(v_606) && success?(is-true(success?(1-proj-3-tuple(v_606))))) then (v_598,2-proj-3-tuple(v_597),true,2-proj-3-tuple(v_606),3-proj-3-tuple(v_606)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {249}event RecvMsg(bob,alice,stagepack_a(sid),plaintext_a);
        {250}event RecvEnd(valid)
    ) | (
        {252}event LeakPsk(phase0,alice,bob);
        {253}out(pub, key_psk(alice,bob))
    ) | (
        {254}phase 1;
        {255}event LeakPsk(phase1,alice,bob);
        {256}out(pub, key_psk(alice,bob))
    ) | (
        {257}event LeakS(phase0,bob);
        {258}out(pub, key_s(bob))
    ) | (
        {259}phase 1;
        {260}event LeakS(phase1,bob);
        {261}out(pub, key_s(bob))
    )
) | (
    {262}let v_610: key = catch-fail(dhexp(key_s(bob),validkey(g))) in
    {263}let s_611: keypair = (if not-caught-fail(v_610) then keypairpack(validkey(v_610),key_s(bob)) else fail-any) in
    {264}out(pub, getpublickey(s_611));
    (
        {265}let e_612: keypair = keypairpack(empty,empty) in
        {266}let v_613: key = catch-fail(dhexp(key_s(charlie),validkey(g))) in
        {267}let rs_614: key = getpublickey((if not-caught-fail(v_613) then keypairpack(validkey(v_613),key_s(charlie)) else fail-any)) in
        {268}let re_615: key = empty in
        {269}let v_616: bitstring = catch-fail(hash(somename,empty)) in
        {270}let v_617: key = catch-fail(v_616) in
        {271}let v_618: cipherstate = catch-fail(cipherstatepack(empty,minnonce)) in
        {272}let v_619: bitstring = catch-fail(symmetricstateunpack((if not-caught-fail(v_616) then (if not-caught-fail(v_617) then (if not-caught-fail(v_618) then symmetricstatepack(v_618,v_617,v_616) else fail-any) else fail-any) else fail-any))) in
        {273}let v_620: symmetricstate = catch-fail((if success?((if not-caught-fail(v_616) then (if not-caught-fail(v_617) then (if not-caught-fail(v_618) then symmetricstatepack(v_618,v_617,v_616) else fail-any) else fail-any) else fail-any)) then (if (not-caught-fail(v_619) && success?(is-true(success?(1-proj-3-tuple(v_619))))) then symmetricstatepack(1-proj-3-tuple(v_619),2-proj-3-tuple(v_619),hash(3-proj-3-tuple(v_619),empty)) else fail-any) else fail-any)) in
        {274}let v_621: bitstring = catch-fail(symmetricstateunpack(v_620)) in
        {275}let v_622: symmetricstate = catch-fail((if (not-caught-fail(v_621) && success?(is-true(success?(1-proj-3-tuple(v_621))))) then symmetricstatepack(1-proj-3-tuple(v_621),2-proj-3-tuple(v_621),hash(3-proj-3-tuple(v_621),rs_614)) else fail-any)) in
        {276}let v_623: bitstring = catch-fail(symmetricstateunpack(v_622)) in
        {277}let v_624: symmetricstate = catch-fail((if success?(getpublickey(s_611)) then (if (not-caught-fail(v_623) && success?(is-true(success?(1-proj-3-tuple(v_623))))) then symmetricstatepack(1-proj-3-tuple(v_623),2-proj-3-tuple(v_623),hash(3-proj-3-tuple(v_623),getpublickey(s_611))) else fail-any) else fail-any)) in
        {278}let hs_625: handshakestate = (if not-caught-fail(v_620) then (if not-caught-fail(v_622) then (if not-caught-fail(v_624) then handshakestatepack(v_624,s_611,e_612,rs_614,re_615,key_psk(charlie,bob),false) else fail-any) else fail-any) else fail-any) in
        {279}insert statestore(bob,charlie,sid,statepack_a(hs_625))
    ) | (
        {337}get statestore(=bob,=charlie,=sid,statepack_a(hs_626: handshakestate)) in
        {280}in(pub, message_a_627: bitstring);
        {281}let v_628: bitstring = catch-fail(handshakestateunpack(hs_626)) in
        {282}let v_629: bitstring = catch-fail(deconcat3(message_a_627)) in
        {283}let v_630: bool = catch-fail(true) in
        {284}let v_631: bitstring = catch-fail(symmetricstateunpack(1-proj-7-tuple(v_628))) in
        {285}let v_632: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_631),6-proj-7-tuple(v_628))) in
        {286}let v_633: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_631),6-proj-7-tuple(v_628))) in
        {287}let v_634: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_631),6-proj-7-tuple(v_628))) in
        {288}let v_635: bitstring = catch-fail((if (success?(6-proj-7-tuple(v_628)) && success?(2-proj-3-tuple(v_631))) then (if not-caught-fail(v_632) then (if not-caught-fail(v_633) then (if not-caught-fail(v_634) then (v_632,v_633,v_634) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {289}let v_636: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_631),1-proj-3-tuple(v_635),3-proj-3-tuple(v_631)))) in
        {290}let v_637: bitstring = catch-fail(symmetricstateunpack((if (success?(2-proj-3-tuple(v_635)) && success?(symmetricstatepack(1-proj-3-tuple(v_631),1-proj-3-tuple(v_635),3-proj-3-tuple(v_631)))) then (if (not-caught-fail(v_636) && success?(is-true(success?(1-proj-3-tuple(v_636))))) then symmetricstatepack(1-proj-3-tuple(v_636),2-proj-3-tuple(v_636),hash(3-proj-3-tuple(v_636),2-proj-3-tuple(v_635))) else fail-any) else fail-any))) in
        {291}let v_638: symmetricstate = catch-fail((if (success?(6-proj-7-tuple(v_628)) && success?(1-proj-7-tuple(v_628))) then (if (not-caught-fail(v_631) && success?(is-true(success?(1-proj-3-tuple(v_631))))) then (if (not-caught-fail(v_635) && success?(is-true(success?(1-proj-3-tuple(v_635))))) then (if (not-caught-fail(v_637) && success?(is-true(success?(1-proj-3-tuple(v_637))))) then symmetricstatepack((if success?(3-proj-3-tuple(v_635)) then cipherstatepack(3-proj-3-tuple(v_635),minnonce) else fail-any),1-proj-3-tuple(v_635),3-proj-3-tuple(v_637)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {292}let v_639: key = catch-fail(1-proj-3-tuple(v_629)) in
        {293}let v_640: bitstring = catch-fail(symmetricstateunpack(v_638)) in
        {294}let v_641: symmetricstate = catch-fail((if (not-caught-fail(v_640) && success?(is-true(success?(1-proj-3-tuple(v_640))))) then symmetricstatepack(1-proj-3-tuple(v_640),2-proj-3-tuple(v_640),hash(3-proj-3-tuple(v_640),v_639)) else fail-any)) in
        {295}let v_642: bitstring = catch-fail(symmetricstateunpack(v_641)) in
        {296}let v_643: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_642),v_639)) in
        {297}let v_644: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_642),v_639)) in
        {298}let v_645: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_642),v_639)) in
        {299}let v_646: bitstring = catch-fail((if success?(2-proj-3-tuple(v_642)) then (if not-caught-fail(v_643) then (if not-caught-fail(v_644) then (if not-caught-fail(v_645) then (v_643,v_644,v_645) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {300}let v_647: symmetricstate = catch-fail((if (not-caught-fail(v_642) && success?(is-true(success?(1-proj-3-tuple(v_642))))) then (if (not-caught-fail(v_646) && success?(is-true(success?(1-proj-3-tuple(v_646))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_646)) then cipherstatepack(2-proj-3-tuple(v_646),minnonce) else fail-any),1-proj-3-tuple(v_646),3-proj-3-tuple(v_642)) else fail-any) else fail-any)) in
        {301}let v_648: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_628))) in
        {302}let v_649: bitstring = catch-fail(symmetricstateunpack(v_647)) in
        {303}let v_650: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_649),(if success?(2-proj-7-tuple(v_628)) then (if (not-caught-fail(v_648) && success?(is-true(success?(1-proj-2-tuple(v_648))))) then dhexp(2-proj-2-tuple(v_648),v_639) else fail-any) else fail-any))) in
        {304}let v_651: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_649),(if success?(2-proj-7-tuple(v_628)) then (if (not-caught-fail(v_648) && success?(is-true(success?(1-proj-2-tuple(v_648))))) then dhexp(2-proj-2-tuple(v_648),v_639) else fail-any) else fail-any))) in
        {305}let v_652: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_649),(if success?(2-proj-7-tuple(v_628)) then (if (not-caught-fail(v_648) && success?(is-true(success?(1-proj-2-tuple(v_648))))) then dhexp(2-proj-2-tuple(v_648),v_639) else fail-any) else fail-any))) in
        {306}let v_653: bitstring = catch-fail((if (success?((if success?(2-proj-7-tuple(v_628)) then (if (not-caught-fail(v_648) && success?(is-true(success?(1-proj-2-tuple(v_648))))) then dhexp(2-proj-2-tuple(v_648),v_639) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_649))) then (if not-caught-fail(v_650) then (if not-caught-fail(v_651) then (if not-caught-fail(v_652) then (v_650,v_651,v_652) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {307}let v_654: symmetricstate = catch-fail((if success?((if success?(2-proj-7-tuple(v_628)) then (if (not-caught-fail(v_648) && success?(is-true(success?(1-proj-2-tuple(v_648))))) then dhexp(2-proj-2-tuple(v_648),v_639) else fail-any) else fail-any)) then (if (not-caught-fail(v_649) && success?(is-true(success?(1-proj-3-tuple(v_649))))) then (if (not-caught-fail(v_653) && success?(is-true(success?(1-proj-3-tuple(v_653))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_653)) then cipherstatepack(2-proj-3-tuple(v_653),minnonce) else fail-any),1-proj-3-tuple(v_653),3-proj-3-tuple(v_649)) else fail-any) else fail-any) else fail-any)) in
        {308}let v_655: bitstring = catch-fail(keypairunpack(2-proj-7-tuple(v_628))) in
        {309}let v_656: bitstring = catch-fail(symmetricstateunpack(v_654)) in
        {310}let v_657: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_656),(if (success?(4-proj-7-tuple(v_628)) && success?(2-proj-7-tuple(v_628))) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_628)) else fail-any) else fail-any))) in
        {311}let v_658: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_656),(if (success?(4-proj-7-tuple(v_628)) && success?(2-proj-7-tuple(v_628))) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_628)) else fail-any) else fail-any))) in
        {312}let v_659: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_656),(if (success?(4-proj-7-tuple(v_628)) && success?(2-proj-7-tuple(v_628))) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_628)) else fail-any) else fail-any))) in
        {313}let v_660: bitstring = catch-fail((if (success?((if (success?(4-proj-7-tuple(v_628)) && success?(2-proj-7-tuple(v_628))) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_628)) else fail-any) else fail-any)) && success?(2-proj-3-tuple(v_656))) then (if not-caught-fail(v_657) then (if not-caught-fail(v_658) then (if not-caught-fail(v_659) then (v_657,v_658,v_659) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {314}let v_661: symmetricstate = catch-fail((if success?((if (success?(4-proj-7-tuple(v_628)) && success?(2-proj-7-tuple(v_628))) then (if (not-caught-fail(v_655) && success?(is-true(success?(1-proj-2-tuple(v_655))))) then dhexp(2-proj-2-tuple(v_655),4-proj-7-tuple(v_628)) else fail-any) else fail-any)) then (if (not-caught-fail(v_656) && success?(is-true(success?(1-proj-3-tuple(v_656))))) then (if (not-caught-fail(v_660) && success?(is-true(success?(1-proj-3-tuple(v_660))))) then symmetricstatepack((if success?(2-proj-3-tuple(v_660)) then cipherstatepack(2-proj-3-tuple(v_660),minnonce) else fail-any),1-proj-3-tuple(v_660),3-proj-3-tuple(v_656)) else fail-any) else fail-any) else fail-any)) in
        {315}let v_662: bitstring = catch-fail(symmetricstateunpack(v_661)) in
        {316}let v_663: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_662))) in
        {317}let v_664: aead = catch-fail(decrypt(1-proj-2-tuple(v_663),2-proj-2-tuple(v_663),3-proj-3-tuple(v_662),3-proj-3-tuple(v_629))) in
        {318}let v_665: bitstring = catch-fail(aeadunpack(v_664)) in
        {319}let v_666: bitstring = catch-fail(cipherstateunpack(1-proj-3-tuple(v_662))) in
        {320}let v_667: cipherstate = catch-fail((if (success?(increment_nonce(2-proj-2-tuple(v_663))) && success?(1-proj-3-tuple(v_662))) then (if (not-caught-fail(v_666) && success?(is-true(success?(1-proj-2-tuple(v_666))))) then cipherstatepack(1-proj-2-tuple(v_666),increment_nonce(2-proj-2-tuple(v_663))) else fail-any) else fail-any)) in
        {321}let v_668: bitstring = catch-fail((if (success?(3-proj-3-tuple(v_629)) && (success?(3-proj-3-tuple(v_662)) && success?(1-proj-3-tuple(v_662)))) then (if (not-caught-fail(v_663) && success?(is-true(success?(1-proj-2-tuple(v_663))))) then (if not-caught-fail(v_664) then (if (not-caught-fail(v_665) && success?(is-true(success?(1-proj-3-tuple(v_665))))) then (if not-caught-fail(v_667) then (v_667,3-proj-3-tuple(v_665),1-proj-3-tuple(v_665)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {322}let v_669: bitstring = catch-fail(symmetricstateunpack(symmetricstatepack(1-proj-3-tuple(v_668),2-proj-3-tuple(v_662),3-proj-3-tuple(v_662)))) in
        {323}let v_670: symmetricstate = catch-fail((if (success?(3-proj-3-tuple(v_629)) && success?(symmetricstatepack(1-proj-3-tuple(v_668),2-proj-3-tuple(v_662),3-proj-3-tuple(v_662)))) then (if (not-caught-fail(v_669) && success?(is-true(success?(1-proj-3-tuple(v_669))))) then symmetricstatepack(1-proj-3-tuple(v_669),2-proj-3-tuple(v_669),hash(3-proj-3-tuple(v_669),3-proj-3-tuple(v_629))) else fail-any) else fail-any)) in
        {324}let v_671: bitstring = catch-fail((if success?(3-proj-3-tuple(v_629)) then (if (not-caught-fail(v_662) && success?(is-true(success?(1-proj-3-tuple(v_662))))) then (if (not-caught-fail(v_668) && success?(is-true(success?(1-proj-3-tuple(v_668))))) then (if not-caught-fail(v_670) then (v_670,2-proj-3-tuple(v_668),3-proj-3-tuple(v_668)) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {325}let v_672: handshakestate = catch-fail(handshakestatepack(1-proj-3-tuple(v_671),2-proj-7-tuple(v_628),3-proj-7-tuple(v_628),4-proj-7-tuple(v_628),v_639,6-proj-7-tuple(v_628),7-proj-7-tuple(v_628))) in
        {326}let v_673: bitstring = catch-fail(symmetricstateunpack(1-proj-3-tuple(v_671))) in
        {327}let v_674: key = catch-fail(hmac_hash1(2-proj-3-tuple(v_673),zero)) in
        {328}let v_675: key = catch-fail(hmac_hash2(2-proj-3-tuple(v_673),zero)) in
        {329}let v_676: key = catch-fail(hmac_hash3(2-proj-3-tuple(v_673),zero)) in
        {330}let v_677: bitstring = catch-fail((if success?(2-proj-3-tuple(v_673)) then (if not-caught-fail(v_674) then (if not-caught-fail(v_675) then (if not-caught-fail(v_676) then (v_674,v_675,v_676) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {331}let v_678: cipherstate = catch-fail((if success?(1-proj-3-tuple(v_677)) then cipherstatepack(1-proj-3-tuple(v_677),minnonce) else fail-any)) in
        {332}let v_679: cipherstate = catch-fail((if success?(2-proj-3-tuple(v_677)) then cipherstatepack(2-proj-3-tuple(v_677),minnonce) else fail-any)) in
        {333}let v_680: bitstring = catch-fail((if success?(1-proj-3-tuple(v_671)) then (if (not-caught-fail(v_673) && success?(is-true(success?(1-proj-3-tuple(v_673))))) then (if (not-caught-fail(v_677) && success?(is-true(success?(1-proj-3-tuple(v_677))))) then (if not-caught-fail(v_678) then (if not-caught-fail(v_679) then (1-proj-3-tuple(v_671),v_678,v_679) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any)) in
        {334}let (hs_681: handshakestate,plaintext_a_682: bitstring,valid_683: bool,cs1_684: cipherstate,cs2_685: cipherstate) = (if (not-caught-fail(v_628) && success?(is-true(success?(1-proj-7-tuple(v_628))))) then (if (not-caught-fail(v_629) && success?(is-true(success?(1-proj-3-tuple(v_629))))) then (if not-caught-fail(v_630) then (if not-caught-fail(v_638) then (if not-caught-fail(v_639) then (if not-caught-fail(v_641) then (if not-caught-fail(v_647) then (if not-caught-fail(v_654) then (if not-caught-fail(v_661) then (if (not-caught-fail(v_671) && success?(is-true(success?(1-proj-3-tuple(v_671))))) then (if (v_630 && 3-proj-3-tuple(v_671)) then (if not-caught-fail(v_672) then (if (not-caught-fail(v_680) && success?(is-true(success?(1-proj-3-tuple(v_680))))) then (v_672,2-proj-3-tuple(v_671),true,2-proj-3-tuple(v_680),3-proj-3-tuple(v_680)) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) else fail-any) in
        {335}event RecvMsg(bob,charlie,stagepack_a(sid),plaintext_a_682);
        {336}event RecvEnd(valid_683)
    ) | (
        {338}event LeakPsk(phase0,charlie,bob);
        {339}out(pub, key_psk(charlie,bob))
    ) | (
        {340}phase 1;
        {341}event LeakPsk(phase1,charlie,bob);
        {342}out(pub, key_psk(charlie,bob))
    ) | (
        {343}event LeakS(phase0,bob);
        {344}out(pub, key_s(bob))
    ) | (
        {345}phase 1;
        {346}event LeakS(phase1,bob);
        {347}out(pub, key_s(bob))
    )
)

-- Query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_795,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_795,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))); not attacker_p1(msg_a(alice,bob,sid_a)); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(px,bob)) && event(LeakPsk(py,alice,bob))); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(px,bob)) && event(LeakPsk(py,alice,bob)) && event(LeakS(pz,alice))); attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))); not event(RecvEnd(true))
Completing...
200 rules inserted. The rule base contains 200 rules. 66 rules in the queue.
400 rules inserted. The rule base contains 371 rules. 46 rules in the queue.
600 rules inserted. The rule base contains 571 rules. 110 rules in the queue.
800 rules inserted. The rule base contains 771 rules. 140 rules in the queue.
1000 rules inserted. The rule base contains 969 rules. 188 rules in the queue.
1200 rules inserted. The rule base contains 1145 rules. 216 rules in the queue.
1400 rules inserted. The rule base contains 1277 rules. 230 rules in the queue.
1600 rules inserted. The rule base contains 1396 rules. 194 rules in the queue.
1800 rules inserted. The rule base contains 1461 rules. 143 rules in the queue.
2000 rules inserted. The rule base contains 1464 rules. 112 rules in the queue.
2200 rules inserted. The rule base contains 1464 rules. 31 rules in the queue.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094076]),msg_a(alice,bob,sid[!1 = @sid_1044094076]))) -> end(RecvMsg(bob,alice,stagepack_a(sid[!1 = @sid_1044094077]),msg_a(alice,bob,sid[!1 = @sid_1044094076])))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_795,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094085]),msg_a(alice,bob,sid[!1 = @sid_1044094085]))) -> end(RecvMsg(bob,alice,stagepack_a(sid[!1 = @sid_1044094086]),msg_a(alice,bob,sid[!1 = @sid_1044094085])))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_795,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_795,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094095]),msg_a(alice,bob,sid[!1 = @sid_1044094095]))) -> end(RecvMsg(bob,alice,stagepack_a(sid[!1 = @sid_1044094096]),msg_a(alice,bob,sid[!1 = @sid_1044094095])))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,c_795,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094105]),msg_a(alice,bob,sid[!1 = @sid_1044094105]))) -> end(RecvMsg(bob,alice,stagepack_a(sid[!1 = @sid_1044094106]),msg_a(alice,bob,sid[!1 = @sid_1044094105])))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) is true.
Starting query event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob)))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094114]),msg_a(alice,bob,sid[!1 = @sid_1044094114]))) -> end(RecvMsg(bob,alice,stagepack_a(sid[!1 = @sid_1044094115]),msg_a(alice,bob,sid[!1 = @sid_1044094114])))
RESULT event(RecvMsg(bob,alice,stagepack_a(sid_b),m)) ==> event(SendMsg(alice,bob,stagepack_a(sid_a),m)) || (event(LeakS(phase0,alice)) && event(LeakPsk(phase0,alice,bob))) is true.
Starting query not attacker_p1(msg_a(alice,bob,sid_a))
goal reachable: begin(LeakS(phase0,bob)) && begin(LeakPsk(phase1,alice,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094122]),msg_a(alice,bob,sid[!1 = @sid_1044094122]))) -> attacker_p1(msg_a(alice,bob,sid[!1 = @sid_1044094122]))
Abbreviations:
sid_1044094252 = sid[!1 = @sid_1044094227]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_1044094252,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true))) may be inserted in a table at insert {21}.
table(statestore(alice,bob,sid_1044094252,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true)))).

3. The entry statestore(alice,bob,sid_1044094252,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true))) that may be in a table by 2 may be read at get {79}.
The event SendMsg(alice,bob,stagepack_a(sid_1044094252),msg_a(alice,bob,sid_1044094252)) may be executed at {77}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252))) may be sent on channel pub at output {78}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))).

8. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))).

9. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

10. The event LeakPsk(phase1,alice,bob) may be executed at {83}.
So the message key_psk(alice,bob) may be sent on channel pub in phase 1 at output {84}.
mess_p1(pub,key_psk(alice,bob)).

11. By 9, the attacker may have the channel pub in phase 1.
By 10, the message key_psk(alice,bob) in phase 1 may be sent on this channel.
So the attacker may obtain the message key_psk(alice,bob) in phase 1 by listening on this channel.
attacker_p1(key_psk(alice,bob)).

12. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

13. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

14. By 13, the attacker may know somename in phase 1.
By 12, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

15. By 14, the attacker may know hash(somename,empty) in phase 1.
By 11, the attacker may know key_psk(alice,bob) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hash(somename,empty),key_psk(alice,bob)) in phase 1.
attacker_p1(hmac_hash2(hash(somename,empty),key_psk(alice,bob))).

16. The message validkey(dhexp_real(key_s(bob),g)) may be sent on channel pub at output {178}.
mess(pub,validkey(dhexp_real(key_s(bob),g))).

17. By 1, the attacker may have the channel pub.
By 16, the message validkey(dhexp_real(key_s(bob),g)) may be sent on this channel.
So the attacker may obtain the message validkey(dhexp_real(key_s(bob),g)) by listening on this channel.
attacker(validkey(dhexp_real(key_s(bob),g))).

18. The message validkey(dhexp_real(key_s(alice),g)) may be sent on channel pub at output {6}.
mess(pub,validkey(dhexp_real(key_s(alice),g))).

19. By 1, the attacker may have the channel pub.
By 18, the message validkey(dhexp_real(key_s(alice),g)) may be sent on this channel.
So the attacker may obtain the message validkey(dhexp_real(key_s(alice),g)) by listening on this channel.
attacker(validkey(dhexp_real(key_s(alice),g))).

20. Using the function empty the attacker may obtain empty.
attacker(empty).

21. Using the function somename the attacker may obtain somename.
attacker(somename).

22. By 21, the attacker may know somename.
By 20, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

23. By 22, the attacker may know hash(somename,empty).
By 20, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

24. By 23, the attacker may know hash(hash(somename,empty),empty).
By 19, the attacker may know validkey(dhexp_real(key_s(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g)))).

25. By 24, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
By 17, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

26. By 25, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))).
So the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

27. By 26, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))) in phase 1.
By 15, the attacker may know hmac_hash2(hash(somename,empty),key_psk(alice,bob)) in phase 1.
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob)))).

28. By 27, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))) in phase 1.
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)) in phase 1.
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)))).

29. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

30. By 19, the attacker may know validkey(dhexp_real(key_s(alice),g)).
So the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_s(alice),g))).

31. The event LeakS(phase0,bob) may be executed at {257}.
So the message key_s(bob) may be sent on channel pub at output {258}.
mess(pub,key_s(bob)).

32. By 1, the attacker may have the channel pub.
By 31, the message key_s(bob) may be sent on this channel.
So the attacker may obtain the message key_s(bob) by listening on this channel.
attacker(key_s(bob)).

33. By 32, the attacker may know key_s(bob).
So the attacker may know key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

34. By 33, the attacker may know key_s(bob) in phase 1.
By 30, the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_s(bob),dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))).

35. By 33, the attacker may know key_s(bob) in phase 1.
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g)) in phase 1.
attacker_p1(dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))).

36. By 14, the attacker may know hash(somename,empty) in phase 1.
By 11, the attacker may know key_psk(alice,bob) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),key_psk(alice,bob)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),key_psk(alice,bob))).

37. By 36, the attacker may know hmac_hash1(hash(somename,empty),key_psk(alice,bob)) in phase 1.
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g)))).

38. By 37, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))) in phase 1.
By 35, the attacker may know dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g)))).

39. By 38, the attacker may know hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))) in phase 1.
By 34, the attacker may know dhexp_real(key_s(bob),dhexp_real(key_s(alice),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g)))).

40. By 39, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))) in phase 1.
By 29, the attacker may know minnonce in phase 1.
By 28, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094252),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252))).

41. By 40, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094252),g))),msg_a(alice,bob,sid_1044094252)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_1044094252) in phase 1.
attacker_p1(msg_a(alice,bob,sid_1044094252)).


RESULT not attacker_p1(msg_a(alice,bob,sid_a)) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(px,bob)) && event(LeakPsk(py,alice,bob)))
goal reachable: begin(LeakS(phase0,bob)) && begin(LeakPsk(phase1,alice,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094254]),msg_a(alice,bob,sid[!1 = @sid_1044094254]))) -> attacker_p1(msg_a(alice,bob,sid[!1 = @sid_1044094254]))
goal reachable: begin(LeakS(phase1,bob)) && begin(LeakPsk(phase1,alice,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094256]),msg_a(alice,bob,sid[!1 = @sid_1044094256]))) -> attacker_p1(msg_a(alice,bob,sid[!1 = @sid_1044094256]))
goal reachable: begin(LeakS(phase1,bob)) && begin(LeakPsk(phase0,alice,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094258]),msg_a(alice,bob,sid[!1 = @sid_1044094258]))) -> attacker_p1(msg_a(alice,bob,sid[!1 = @sid_1044094258]))
goal reachable: begin(LeakS(phase0,bob)) && begin(LeakPsk(phase0,alice,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094261]),msg_a(alice,bob,sid[!1 = @sid_1044094261]))) -> attacker_p1(msg_a(alice,bob,sid[!1 = @sid_1044094261]))
RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(px,bob)) && event(LeakPsk(py,alice,bob))) is true.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(px,bob)) && event(LeakPsk(py,alice,bob)) && event(LeakS(pz,alice)))
goal reachable: begin(LeakS(phase0,bob)) && begin(LeakPsk(phase1,alice,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094279]),msg_a(alice,bob,sid[!1 = @sid_1044094279]))) -> attacker_p1(msg_a(alice,bob,sid[!1 = @sid_1044094279]))
Abbreviations:
sid_1044094412 = sid[!1 = @sid_1044094387]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_1044094412,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true))) may be inserted in a table at insert {21}.
table(statestore(alice,bob,sid_1044094412,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true)))).

3. The entry statestore(alice,bob,sid_1044094412,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true))) that may be in a table by 2 may be read at get {79}.
The event SendMsg(alice,bob,stagepack_a(sid_1044094412),msg_a(alice,bob,sid_1044094412)) may be executed at {77}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412))) may be sent on channel pub at output {78}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))).

8. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))).

9. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

10. The event LeakPsk(phase1,alice,bob) may be executed at {83}.
So the message key_psk(alice,bob) may be sent on channel pub in phase 1 at output {84}.
mess_p1(pub,key_psk(alice,bob)).

11. By 9, the attacker may have the channel pub in phase 1.
By 10, the message key_psk(alice,bob) in phase 1 may be sent on this channel.
So the attacker may obtain the message key_psk(alice,bob) in phase 1 by listening on this channel.
attacker_p1(key_psk(alice,bob)).

12. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

13. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

14. By 13, the attacker may know somename in phase 1.
By 12, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

15. By 14, the attacker may know hash(somename,empty) in phase 1.
By 11, the attacker may know key_psk(alice,bob) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hash(somename,empty),key_psk(alice,bob)) in phase 1.
attacker_p1(hmac_hash2(hash(somename,empty),key_psk(alice,bob))).

16. The message validkey(dhexp_real(key_s(bob),g)) may be sent on channel pub at output {178}.
mess(pub,validkey(dhexp_real(key_s(bob),g))).

17. By 1, the attacker may have the channel pub.
By 16, the message validkey(dhexp_real(key_s(bob),g)) may be sent on this channel.
So the attacker may obtain the message validkey(dhexp_real(key_s(bob),g)) by listening on this channel.
attacker(validkey(dhexp_real(key_s(bob),g))).

18. The message validkey(dhexp_real(key_s(alice),g)) may be sent on channel pub at output {6}.
mess(pub,validkey(dhexp_real(key_s(alice),g))).

19. By 1, the attacker may have the channel pub.
By 18, the message validkey(dhexp_real(key_s(alice),g)) may be sent on this channel.
So the attacker may obtain the message validkey(dhexp_real(key_s(alice),g)) by listening on this channel.
attacker(validkey(dhexp_real(key_s(alice),g))).

20. Using the function empty the attacker may obtain empty.
attacker(empty).

21. Using the function somename the attacker may obtain somename.
attacker(somename).

22. By 21, the attacker may know somename.
By 20, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

23. By 22, the attacker may know hash(somename,empty).
By 20, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

24. By 23, the attacker may know hash(hash(somename,empty),empty).
By 19, the attacker may know validkey(dhexp_real(key_s(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g)))).

25. By 24, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
By 17, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

26. By 25, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))).
So the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

27. By 26, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))) in phase 1.
By 15, the attacker may know hmac_hash2(hash(somename,empty),key_psk(alice,bob)) in phase 1.
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob)))).

28. By 27, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))) in phase 1.
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)) in phase 1.
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)))).

29. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

30. By 19, the attacker may know validkey(dhexp_real(key_s(alice),g)).
So the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_s(alice),g))).

31. The event LeakS(phase0,bob) may be executed at {257}.
So the message key_s(bob) may be sent on channel pub at output {258}.
mess(pub,key_s(bob)).

32. By 1, the attacker may have the channel pub.
By 31, the message key_s(bob) may be sent on this channel.
So the attacker may obtain the message key_s(bob) by listening on this channel.
attacker(key_s(bob)).

33. By 32, the attacker may know key_s(bob).
So the attacker may know key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

34. By 33, the attacker may know key_s(bob) in phase 1.
By 30, the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_s(bob),dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))).

35. By 33, the attacker may know key_s(bob) in phase 1.
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g)) in phase 1.
attacker_p1(dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))).

36. By 14, the attacker may know hash(somename,empty) in phase 1.
By 11, the attacker may know key_psk(alice,bob) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),key_psk(alice,bob)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),key_psk(alice,bob))).

37. By 36, the attacker may know hmac_hash1(hash(somename,empty),key_psk(alice,bob)) in phase 1.
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g)))).

38. By 37, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))) in phase 1.
By 35, the attacker may know dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g)))).

39. By 38, the attacker may know hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))) in phase 1.
By 34, the attacker may know dhexp_real(key_s(bob),dhexp_real(key_s(alice),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g)))).

40. By 39, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))) in phase 1.
By 29, the attacker may know minnonce in phase 1.
By 28, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094412),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412))).

41. By 40, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094412),g))),msg_a(alice,bob,sid_1044094412)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_1044094412) in phase 1.
attacker_p1(msg_a(alice,bob,sid_1044094412)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) || (event(LeakS(px,bob)) && event(LeakPsk(py,alice,bob)) && event(LeakS(pz,alice))) cannot be proved.
Starting query attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob)))
goal reachable: begin(LeakS(phase0,bob)) && begin(LeakPsk(phase1,alice,bob)) && begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094414]),msg_a(alice,bob,sid[!1 = @sid_1044094414]))) -> attacker_p1(msg_a(alice,bob,sid[!1 = @sid_1044094414]))
Abbreviations:
sid_1044094544 = sid[!1 = @sid_1044094519]

1. Using the function pub the attacker may obtain pub.
attacker(pub).

2. The entry statestore(alice,bob,sid_1044094544,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true))) may be inserted in a table at insert {21}.
table(statestore(alice,bob,sid_1044094544,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true)))).

3. The entry statestore(alice,bob,sid_1044094544,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true))) that may be in a table by 2 may be read at get {79}.
The event SendMsg(alice,bob,stagepack_a(sid_1044094544),msg_a(alice,bob,sid_1044094544)) may be executed at {77}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544))) may be sent on channel pub at output {78}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544)))).

4. By 1, the attacker may have the channel pub.
By 3, the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544))) may be sent on this channel.
So the attacker may obtain the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544))) by listening on this channel.
attacker(concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544)))).

5. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544))).
Using the function 3-proj-concat3 the attacker may obtain encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544)).
attacker(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544))).

6. By 5, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544)).
So the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544)) in phase 1.
attacker_p1(encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544))).

7. By 4, the attacker may know concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544))).
Using the function 1-proj-concat3 the attacker may obtain validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)).
attacker(validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))).

8. By 7, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)).
So the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))).

9. Using the function pub the attacker may obtain pub in phase 1.
attacker_p1(pub).

10. The event LeakPsk(phase1,alice,bob) may be executed at {83}.
So the message key_psk(alice,bob) may be sent on channel pub in phase 1 at output {84}.
mess_p1(pub,key_psk(alice,bob)).

11. By 9, the attacker may have the channel pub in phase 1.
By 10, the message key_psk(alice,bob) in phase 1 may be sent on this channel.
So the attacker may obtain the message key_psk(alice,bob) in phase 1 by listening on this channel.
attacker_p1(key_psk(alice,bob)).

12. Using the function empty the attacker may obtain empty in phase 1.
attacker_p1(empty).

13. Using the function somename the attacker may obtain somename in phase 1.
attacker_p1(somename).

14. By 13, the attacker may know somename in phase 1.
By 12, the attacker may know empty in phase 1.
Using the function hash the attacker may obtain hash(somename,empty) in phase 1.
attacker_p1(hash(somename,empty)).

15. By 14, the attacker may know hash(somename,empty) in phase 1.
By 11, the attacker may know key_psk(alice,bob) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hash(somename,empty),key_psk(alice,bob)) in phase 1.
attacker_p1(hmac_hash2(hash(somename,empty),key_psk(alice,bob))).

16. The message validkey(dhexp_real(key_s(bob),g)) may be sent on channel pub at output {178}.
mess(pub,validkey(dhexp_real(key_s(bob),g))).

17. By 1, the attacker may have the channel pub.
By 16, the message validkey(dhexp_real(key_s(bob),g)) may be sent on this channel.
So the attacker may obtain the message validkey(dhexp_real(key_s(bob),g)) by listening on this channel.
attacker(validkey(dhexp_real(key_s(bob),g))).

18. The message validkey(dhexp_real(key_s(alice),g)) may be sent on channel pub at output {6}.
mess(pub,validkey(dhexp_real(key_s(alice),g))).

19. By 1, the attacker may have the channel pub.
By 18, the message validkey(dhexp_real(key_s(alice),g)) may be sent on this channel.
So the attacker may obtain the message validkey(dhexp_real(key_s(alice),g)) by listening on this channel.
attacker(validkey(dhexp_real(key_s(alice),g))).

20. Using the function empty the attacker may obtain empty.
attacker(empty).

21. Using the function somename the attacker may obtain somename.
attacker(somename).

22. By 21, the attacker may know somename.
By 20, the attacker may know empty.
Using the function hash the attacker may obtain hash(somename,empty).
attacker(hash(somename,empty)).

23. By 22, the attacker may know hash(somename,empty).
By 20, the attacker may know empty.
Using the function hash the attacker may obtain hash(hash(somename,empty),empty).
attacker(hash(hash(somename,empty),empty)).

24. By 23, the attacker may know hash(hash(somename,empty),empty).
By 19, the attacker may know validkey(dhexp_real(key_s(alice),g)).
Using the function hash the attacker may obtain hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
attacker(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g)))).

25. By 24, the attacker may know hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))).
By 17, the attacker may know validkey(dhexp_real(key_s(bob),g)).
Using the function hash the attacker may obtain hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))).
attacker(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

26. By 25, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))).
So the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))).

27. By 26, the attacker may know hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))) in phase 1.
By 15, the attacker may know hmac_hash2(hash(somename,empty),key_psk(alice,bob)) in phase 1.
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob)))).

28. By 27, the attacker may know hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))) in phase 1.
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)) in phase 1.
Using the function hash the attacker may obtain hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))) in phase 1.
attacker_p1(hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)))).

29. Using the function minnonce the attacker may obtain minnonce in phase 1.
attacker_p1(minnonce).

30. By 19, the attacker may know validkey(dhexp_real(key_s(alice),g)).
So the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(validkey(dhexp_real(key_s(alice),g))).

31. The event LeakS(phase0,bob) may be executed at {257}.
So the message key_s(bob) may be sent on channel pub at output {258}.
mess(pub,key_s(bob)).

32. By 1, the attacker may have the channel pub.
By 31, the message key_s(bob) may be sent on this channel.
So the attacker may obtain the message key_s(bob) by listening on this channel.
attacker(key_s(bob)).

33. By 32, the attacker may know key_s(bob).
So the attacker may know key_s(bob) in phase 1.
attacker_p1(key_s(bob)).

34. By 33, the attacker may know key_s(bob) in phase 1.
By 30, the attacker may know validkey(dhexp_real(key_s(alice),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_s(bob),dhexp_real(key_s(alice),g)) in phase 1.
attacker_p1(dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))).

35. By 33, the attacker may know key_s(bob) in phase 1.
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)) in phase 1.
Using the function dhexp the attacker may obtain dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g)) in phase 1.
attacker_p1(dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))).

36. By 14, the attacker may know hash(somename,empty) in phase 1.
By 11, the attacker may know key_psk(alice,bob) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hash(somename,empty),key_psk(alice,bob)) in phase 1.
attacker_p1(hmac_hash1(hash(somename,empty),key_psk(alice,bob))).

37. By 36, the attacker may know hmac_hash1(hash(somename,empty),key_psk(alice,bob)) in phase 1.
By 8, the attacker may know validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g)))).

38. By 37, the attacker may know hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))) in phase 1.
By 35, the attacker may know dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g)) in phase 1.
Using the function hmac_hash1 the attacker may obtain hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))) in phase 1.
attacker_p1(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g)))).

39. By 38, the attacker may know hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))) in phase 1.
By 34, the attacker may know dhexp_real(key_s(bob),dhexp_real(key_s(alice),g)) in phase 1.
Using the function hmac_hash2 the attacker may obtain hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))) in phase 1.
attacker_p1(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g)))).

40. By 39, the attacker may know hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))) in phase 1.
By 29, the attacker may know minnonce in phase 1.
By 28, the attacker may know hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))) in phase 1.
By 6, the attacker may know encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094544),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544)) in phase 1.
Using the function decrypt the attacker may obtain aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544)) in phase 1.
attacker_p1(aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544))).

41. By 40, the attacker may know aeadpack(true,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094544),g))),msg_a(alice,bob,sid_1044094544)) in phase 1.
Using the function 3-proj-aeadpack the attacker may obtain msg_a(alice,bob,sid_1044094544) in phase 1.
attacker_p1(msg_a(alice,bob,sid_1044094544)).


RESULT attacker_p1(msg_a(alice,bob,sid_a)) ==> (event(LeakS(phase0,bob)) && event(LeakPsk(phase0,alice,bob))) cannot be proved.
Starting query not event(RecvEnd(true))
goal reachable: begin(SendMsg(alice,bob,stagepack_a(sid[!1 = @sid_1044094545]),msg_a(alice,bob,sid[!1 = @sid_1044094545]))) -> end(RecvEnd(true))
Abbreviations:
sid_1044094574 = sid[!1 = @sid_1044094549]
sid_1044094575 = sid[!1 = @sid_1044094568]

1. The entry statestore(bob,alice,sid_1044094575,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(empty,empty),validkey(dhexp_real(key_s(alice),g)),empty,key_psk(alice,bob),false))) may be inserted in a table at insert {193}.
table(statestore(bob,alice,sid_1044094575,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(empty,empty),validkey(dhexp_real(key_s(alice),g)),empty,key_psk(alice,bob),false)))).

2. The entry statestore(alice,bob,sid_1044094574,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true))) may be inserted in a table at insert {21}.
table(statestore(alice,bob,sid_1044094574,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true)))).

3. The entry statestore(alice,bob,sid_1044094574,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(alice),g)),key_s(alice)),keypairpack(empty,empty),validkey(dhexp_real(key_s(bob),g)),empty,key_psk(alice,bob),true))) that may be in a table by 2 may be read at get {79}.
The event SendMsg(alice,bob,stagepack_a(sid_1044094574),msg_a(alice,bob,sid_1044094574)) may be executed at {77}.
So the message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094574),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094574),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094574),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094574),g))),msg_a(alice,bob,sid_1044094574))) may be sent on channel pub at output {78}.
mess(pub,concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094574),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094574),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094574),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094574),g))),msg_a(alice,bob,sid_1044094574)))).

4. The entry statestore(bob,alice,sid_1044094575,statepack_a(handshakestatepack(symmetricstatepack(cipherstatepack(empty,minnonce),hash(somename,empty),hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g)))),keypairpack(validkey(dhexp_real(key_s(bob),g)),key_s(bob)),keypairpack(empty,empty),validkey(dhexp_real(key_s(alice),g)),empty,key_psk(alice,bob),false))) that may be in a table by 1 may be read at get {251}.
The message concat3(validkey(dhexp_real(key_e(alice,bob,sid_1044094574),g)),empty,encrypt(hmac_hash2(hmac_hash1(hmac_hash1(hmac_hash1(hash(somename,empty),key_psk(alice,bob)),validkey(dhexp_real(key_e(alice,bob,sid_1044094574),g))),dhexp_real(key_s(bob),dhexp_real(key_e(alice,bob,sid_1044094574),g))),dhexp_real(key_s(bob),dhexp_real(key_s(alice),g))),minnonce,hash(hash(hash(hash(hash(hash(somename,empty),empty),validkey(dhexp_real(key_s(alice),g))),validkey(dhexp_real(key_s(bob),g))),hmac_hash2(hash(somename,empty),key_psk(alice,bob))),validkey(dhexp_real(key_e(alice,bob,sid_1044094574),g))),msg_a(alice,bob,sid_1044094574))) that may be sent on channel pub by 3 may be received at input {194}.
So event RecvEnd(true) may be executed at {250}.
end(RecvEnd(true)).


RESULT not event(RecvEnd(true)) cannot be proved.
